<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SRIORestUploadBundle - Resumable upload way</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Handle multiple upload ways on your Symfony2 REST API - Resumable upload way">
    <meta name="author" content="Samuel ROZE">
    <meta name="keywords" content="srio, rest, upload, bundle, symfony2, resumable, multipart" />

    <!-- Le styles -->
    <link href="assets/css/vendor/1-bootstrap.min.css" rel="stylesheet" />
    <link href="assets/css/vendor/1-bootstrap-theme.min.css" rel="stylesheet" />
    <link href="assets/css/vendor/3-prettify.css" rel="stylesheet" />
    <link href="assets/css/docs.css" rel="stylesheet" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Top scripts -->
    <script type="text/javascript" src="assets/js/vendor/1-jquery-1.9.1.js"></script>
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-41885358-2', 'sroze.github.io');
        ga('send', 'pageview');
    </script>
</head>
<body>
    <header class="docs-header">
        <a href="index.html" class="pull-right btn btn-default">Go back to index</a>
        <h1>SRIORestUploadBundle</h1>
        <h2>Handle multiple upload ways on your Symfony2 REST API</h2>
    </header>

    <div class="bs-docs-social">
        <div class="container">
            <ul class="bs-docs-social-buttons">
                <li>
                    <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=sroze&repo=SRIORestUploadBundle&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="100px" height="20px"></iframe>
                </li>
                <li>
                    <a href="https://travis-ci.org/sroze/SRIORestUploadBundle" title="Travis Build Status"><img src="https://api.travis-ci.org/sroze/SRIORestUploadBundle.png" /></a>
                </li>
            </ul>
        </div>
    </div>

    <div class="container documentation">
        <div class="row" id="multipartWay">
            <div class="col-lg-12">
                <h1 itemscope itemtype="http://data-vocabulary.org/Breadcrumb">

                    <a href="index.html#uploadWays" itemprop="url">
                        <span itemprop="title">Upload ways</span>
                    </a> &raquo;
                    <span itemprop="child" itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
                        <a href="upload-resumable.html" itemprop="url">
                            <span itemprop="title">Resumable upload way</span>
                        </a>
                    </span>
                </h1>
            </div>
        </div>
        <div class="row">
            <div class="col-lg-12">
                <p>To upload data files more reliably, you can use the resumable upload protocol. This protocol allows you to resume an upload operation after a communication failure has interrupted the flow of data. It is especially useful if you are transferring large files and the likelihood of a network interruption or some other transmission failure is high, for example, when uploading from a mobile client app. It can also reduce your bandwidth usage in the event of network failures because you don&#39;t have to restart large file uploads from the beginning.</p>

                <p>The steps for using resumable upload include:</p>
                <ol>
                    <li><a href="#start-resumable">Start a resumable session</a>. Make an initial request to the upload URI that includes the metadata, if any.</li>
                    <li><a href="#save-session-uri">Save the resumable session URI</a>. Save the session URI returned in the response of the initial request; you'll use it for the remaining requests in this session.</li>
                    <li><a href="#upload-resumable">Upload the file</a>. Send the media file to the resumable session URI.</li>
                </ol>

                <p>In addition, apps that use resumable upload need to have code to <a href="#resume-upload">resume an interrupted upload</a>. If an upload is interrupted, find out how much data was successfully received, and then resume the upload starting from that point.</p>

                <h1 id="start-resumable">Start a resumable session</h1>
                <p>For this initiating request, the body is either empty or it contains the metadata only; you'll transfer the actual contents of the file you want to upload in subsequent requests.</p>

                <p>Use the following HTTP headers with the initial request:</p>
                <ul>
                    <li><code>X-Upload-Content-Type</code>. Set to the media MIME type of the upload data to be transferred in subsequent requests.</li>
                    <li><code>X-Upload-Content-Length</code>. Set to the number of bytes of upload data to be transferred in subsequent requests.</li>
                    <li><code>Content-Type</code>. Set according to the metadata's data type.</li>
                    <li><code>Content-Length</code>. Set to the number of bytes provided in the body of this initial request.</li>
                </ul>

                <p>The following example shows the use of a resumable upload request for an upload path that would be <code>/upload</code>:</p>

                <pre class="prettyprint">POST /upload?uploadType=resumable HTTP/1.1
Host: www.example.com
Content-Length: 41
Content-Type: application/json; charset=UTF-8
X-Upload-Content-Type: image/jpeg
X-Upload-Content-Length: 2000000

{
    "name": "Some value"
}</pre>

                <h1 id="save-session-uri">Save the resumable session URI</h1>
                <p>If the session initiation request succeeds, the API server responds with a <code>200 OK</code> HTTP status code. In addition, it provides a <code>Location</code> header that specifies your resumable session URI. The <code>Location</code> header, shown in the example below, includes an <code>uploadId</code> query parameter portion that gives the unique upload ID to use for this session.</p>
                <p>Here is the response to the request in the last step:</p>
                <pre class="prettyprint">HTTP/1.1 200 OK
Location: /upload?uploadType=resumable&uploadId=fooBar123
Content-Length: 0</pre>

                <p>The value of the <code>Location</code> header, as shown in the above example response, is the session URI you'll use as the HTTP endpoint for doing the actual file upload or querying the upload status.</p>

                <h1 id="upload-resumable">Upload the file</h1>
                <p>To upload the file, send a <code>PUT</code> request to the upload URI that you obtained in the previous step.</p>
                <p>The HTTP headers to use when making the resumable file upload requests includes <code>Content-Length</code>. Set this to the number of bytes you are uploading in this request, which is generally the upload file size.</p>

                <pre class="prettyprint">PUT /upload?uploadType=resumable&uploadId=fooBar123 HTTP/1.1
Content-Length: 2000000
Content-Type: image/jpeg

<em>bytes 0-1999999</em></pre>
                <p>If the request succeeds, the server responds with an HTTP <code>201 Created</code>, along with any metadata associated with this resource. If the initial request of the resumable session had been a <code>PUT</code>, to update an existing resource, the success response would be <code>200 OK</code>, along with any metadata associated with this resource.</p>

                <h1 id="upload-chunks">Upload file in chunks</h1>
                <p>With resumable uploads, you can break a file into chunks and send a series of requests to upload each chunk in sequence. This is not the preferred approach since there are performance costs associated with the additional requests, and it is generally not needed. However, you might need to use chunking to reduce the amount of data transferred in any single request.</p>
                <p>If you are uploading the data in chunks, the <code>Content-Range</code> header is also required, along with the <code>Content-Length</code> header required for full file uploads:</p>
                <ul>
                    <li><code>Content-Length</code>. Set to the chunk size or possibly less, as might be the case for the last request.</li>
                    <li><code>Content-Range</code>: Set to show which bytes in the file you are uploading. For example, <code>Content-Range: bytes 0-524287/2000000</code> shows that you are providing the first 524,288 bytes in a 2,000,000 byte file.</li>
                </ul>

                <p>A sample request would be:</p>
                <pre class="prettyprint">PUT <em>{session_uri}</em> HTTP/1.1
Host: www.example.com
Content-Length: 524288
Content-Type: image/jpeg
Content-Range: bytes 0-524287/2000000

<em>bytes 0-524288</em></pre>
                <p>If the request succeeds, the server responds with <code>308 Resume Incomplete</code>, along with a <code>Range</code> header that identifies the total number of bytes that have been stored so far:</p>
                <pre class="prettyprint">HTTP/1.1 308 Resume Incomplete
Content-Length: 0
Range: 0-524287</pre>
                <p>Use the upper value returned in the <code>Range</code> header to determine where to start the next chunk. Continue to PUT each chunk of the file until the entire file has been uploaded</p>

                <h1 id="resume-upload">Resume an interrupted upload</h1>
                <p>If an upload request is terminated before receiving a response or if you receive an HTTP <code>503 Service Unavailable</code> or even an HTTP <code>500 Internal Server Error</code> response from the server, then you need to resume the interrupted upload. To do this:</p>
                <ol>
                    <li>
                        <p><strong>Request the upload status</strong></p>
                        <pre class="prettyprint">PUT {session_uri} HTTP/1.1
Content-Length: 0
Content-Range: bytes */2000000</pre>
                    </li>
                    <li>
                        <p><strong>Extract the number of bytes uploaded so far from the response</strong></p>
                        <p>The server's response uses the <code>Range</code> header to indicate that it has received the first 43 bytes of the file so far. Use the upper value of the <code>Range</code> header to determine where to start the resumed upload.</p>
                        <pre class="prettyprint">HTTP/1.1 308 Resume Incomplete
Content-Length: 0
Range: 0-42</pre>
                    </li>
                    <li>
                        <p><strong>Resume the upload from the point where it left off</strong></p>
                        <p>Use the <a href="#upload-chunks">upload file in chunks</a> method to restart upload at the point where there's a failure.</p>
                    </li>
                </ol>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div class="container">
            <p>Designed and built with love by <a href="http://github.com/sroze" target="_blank">@sroze</a>.</p>
            <p>Code licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>, documentation under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
        </div>
    </footer>

    <script type="text/javascript" src="assets/js/vendor/2-bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/js/vendor/1-json2.js"></script>
    <script type="text/javascript" src="assets/js/vendor/prettify.js"></script>
    <script type="text/javascript" src="assets/js/docs.js"></script>
</body>
</html>